<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Callista&#39;s Blog</title>
  
  
  <link href="http://blog.starant.link/atom.xml" rel="self"/>
  
  <link href="http://blog.starant.link/"/>
  <updated>2023-08-01T06:17:25.049Z</updated>
  <id>http://blog.starant.link/</id>
  
  <author>
    <name>Callista</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>badusb制作</title>
    <link href="http://blog.starant.link/posts/55422.html"/>
    <id>http://blog.starant.link/posts/55422.html</id>
    <published>2023-08-01T04:58:51.000Z</published>
    <updated>2023-08-01T06:17:25.049Z</updated>
    
    <content type="html"><![CDATA[<h2 id="badusb制作"><a href="#badusb制作" class="headerlink" title="badusb制作"></a>badusb制作</h2><h3 id="1-购买Digspark开发板"><a href="#1-购买Digspark开发板" class="headerlink" title="1.购买Digspark开发板"></a>1.购买Digspark开发板</h3><p><img src="/picture/badusb/de79b84937d714eebb7068275a3b7fb.png" alt="Alt text"><br>一个10块钱左右</p><h3 id="2-安装驱动"><a href="#2-安装驱动" class="headerlink" title="2.安装驱动"></a>2.安装驱动</h3><p>Digispark驱动程序 (Windows)：<a href="https://github.com/digistump/DigistumpArduino/releases">https://github.com/digistump/DigistumpArduino/releases</a><br>下载，Digistump.Drivers.zip，解压，运行DPinst64.exe，三个都是勾即可<br><img src="/picture/badusb/ea865d6e81a54f76545216f112544fd.png" alt="Alt text"><br><img src="/picture/badusb/3d111308409bd3237e320a867155b25.png" alt="Alt text"></p><h3 id="3-下载Arduino-IDE"><a href="#3-下载Arduino-IDE" class="headerlink" title="3.下载Arduino IDE"></a>3.下载Arduino IDE</h3><p>下载Arduino IDE： <a href="https://www.arduino.cc/en/Main/Software">https://www.arduino.cc/en/Main/Software</a><br>下载最新版即可<br><img src="/picture/badusb/edd919d3cc41f62754a013026e9ae0d.png" alt="Alt text"></p><h3 id="4-配置Arduino-IDE"><a href="#4-配置Arduino-IDE" class="headerlink" title="4.配置Arduino IDE"></a>4.配置Arduino IDE</h3><p>打开 文件-&gt;首选项<br>把这个网址添加到附加开发板管理网址<a href="http://digistump.com/package_digistump_index.json%EF%BC%8C%E4%B8%8B%E8%BD%BD%E5%A4%B1%E8%B4%A5%E7%9A%84%E8%AF%9D%EF%BC%8C%E5%8F%AF%E8%83%BD%E8%A6%81%E6%8C%82%E6%A2%AF%E5%AD%90">http://digistump.com/package_digistump_index.json，下载失败的话，可能要挂梯子</a><br><img src="/picture/badusb/image-6.png" alt="Alt text"></p><p>打开 工具-&gt;开发板管理器，找到Digistump AVR Boards进行安装，安装失败可能要挂梯子<br><img src="/picture/badusb/image.png" alt="Alt text"></p><h3 id="5-添加DEMO并烧录"><a href="#5-添加DEMO并烧录" class="headerlink" title="5.添加DEMO并烧录"></a>5.添加DEMO并烧录</h3><p>选择开发板：工具-&gt;开发板-&gt;Digistump AVR Boards-&gt;Digspark(defealt)<br><img src="/picture/badusb/image-1.png" alt="Alt text"></p><p>新建示例：文件-&gt;示例-&gt;DigsparkKeyboard-&gt;Keyboard<br><img src="/picture/badusb/image-2.png" alt="Alt text"></p><p>示例代码：<br><img src="/picture/badusb/image-3.png" alt="Alt text"><br>示例的意思是每隔5秒模拟键盘输入一次Hello Digispark!</p><p>上传示例：点击左上角的右箭头<br><img src="/picture/badusb/image-4.png" alt="Alt text"></p><p>这时候插入Digspark开发板即可，在这之前都不要插入开发板<br><img src="/picture/badusb/image-5.png" alt="Alt text"><br>看到Thank you！就是烧录成功了，每隔5秒便会输入一次Hello Digispark。</p><h3 id="6-利用badusb载入免杀马"><a href="#6-利用badusb载入免杀马" class="headerlink" title="6.利用badusb载入免杀马"></a>6.利用badusb载入免杀马</h3><p>可利用badusb打开cmd，载入curl下载免杀马然后执行。</p><h3 id="免责声明"><a href="#免责声明" class="headerlink" title="免责声明"></a>免责声明</h3><p>本文章仅供学习用途，请勿进行非法活动。读者在使用本文章提供的信息时，应遵守相关法律法规，不得违反国家法律，不得进行任何损害他人合法权益的行为。任何非法活动造成的一切后果，由行为人自行承担。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;badusb制作&quot;&gt;&lt;a href=&quot;#badusb制作&quot; class=&quot;headerlink&quot; title=&quot;badusb制作&quot;&gt;&lt;/a&gt;badusb制作&lt;/h2&gt;&lt;h3 id=&quot;1-购买Digspark开发板&quot;&gt;&lt;a href=&quot;#1-购买Digspark开发</summary>
      
    
    
    
    <category term="编程" scheme="http://blog.starant.link/categories/programming/"/>
    
    
    <category term="https" scheme="http://blog.starant.link/tags/https/"/>
    
    <category term="网络安全" scheme="http://blog.starant.link/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>https协议为什么能够防止劫持</title>
    <link href="http://blog.starant.link/posts/58256.html"/>
    <id>http://blog.starant.link/posts/58256.html</id>
    <published>2023-07-20T04:58:51.000Z</published>
    <updated>2023-07-21T08:28:31.165Z</updated>
    
    <content type="html"><![CDATA[<h2 id="https协议为什么能够防止劫持"><a href="#https协议为什么能够防止劫持" class="headerlink" title="https协议为什么能够防止劫持"></a>https协议为什么能够防止劫持</h2><p>在讲https为什么能够防止劫持之前，先讲讲http为什么会被劫持。</p><h3 id="http劫持"><a href="#http劫持" class="headerlink" title="http劫持"></a>http劫持</h3><p>因为http是直接在tcp协议之上的，tcp协议本身不是加密协议，所以导致http协议的数据在网络中传输完全是明文的。http劫持就是，在客户端和服务端之间建立一个监听服务器，那么客户端和服务器之间的所有数据都可以被这个监听服务器监听到，那么当客户端向服务器发送的密码等敏感数据就会被劫持。所以当时https出现就是为了解决http劫持的问题，使用户的会话能够得到保护。</p><h3 id="https与http的区别"><a href="#https与http的区别" class="headerlink" title="https与http的区别"></a>https与http的区别</h3><p>https的原理就是通过TLS协议对http的传输进行加密，https与http的区别就是比http多了一层TLS，那么TLS真的可以保护我们的数据不被中间人劫持吗。</p><h3 id="为什么https劫持不可能"><a href="#为什么https劫持不可能" class="headerlink" title="为什么https劫持不可能"></a>为什么https劫持不可能</h3><p>假如直接进行劫持，因为https是通过tls进行加密传输的，加密和解密都需要对应的密钥，如果直接对https数据直接进行劫持，那么截获的数据就只会是一堆乱码的密文，因为我们是中间人，并没有解密的密钥。那我们是不是可以从https的上一层tls握手开始进行劫持，是不是能够劫持到密钥。</p><h4 id="TLS握手过程"><a href="#TLS握手过程" class="headerlink" title="TLS握手过程"></a>TLS握手过程</h4><ol><li>客户端发送 ClientHello：TLS 握手开始时，客户端向服务器发送一个称为 ClientHello 的消息。该消息包含支持的 TLS 版本号、加密套件列表和随机数等信息。</li><li>服务器回应 ServerHello：服务器收到 ClientHello 后，从客户端提供的加密套件列表中选择一个加密套件，并生成一个随机数。然后服务器将其作为 ServerHello 消息的一部分回复给客户端，同时发送服务器证书（或公钥）。</li><li>客户端验证服务器证书：客户端接收到服务器的 ServerHello 和证书后，会验证证书的合法性。这涉及到检查证书的签名、有效期、颁发机构等信息，以确保连接到的是合法的服务器。</li><li>客户端生成密钥：客户端生成一个用于本次会话的临时密钥，称为 Pre-Master Secret。然后使用服务器的公钥（或从证书中提取的公钥）对 Pre-Master Secret 进行加密，并将其发送给服务器。</li><li>服务器解密 Pre-Master Secret：服务器收到客户端发送的加密 Pre-Master Secret 后，使用自己的私钥对其进行解密，得到 Pre-Master Secret。</li><li>客户端和服务器生成会话密钥：客户端和服务器使用在握手过程中交换的随机数和 Pre-Master Secret 来生成会话密钥（Session Key）。这个会话密钥将用于加密和解密会话中的数据。</li><li>客户端发送 Finished 消息：客户端使用会话密钥加密一条 Finished 消息，并发送给服务器，以通知服务器握手过程已经完成。</li><li>服务器发送 Finished 消息：服务器也使用会话密钥加密一条 Finished 消息，并发送给客户端，以确认握手过程的完成</li></ol><p>假如我们作为一个中间人，当我们第一步我们可以获得客户端的随机数C，第二步我们可以获得服务器的随机数S和服务器的证书，第三步我们不需要验证，第四步我们可以截获由证书公钥加密的临时密钥，但由于这是一个公钥加密的数据，我们作为中间人，无法解密里面的数据，因为私钥只有服务器有，之后的步骤也就进行不下去了，也就无法获取最终生成的TLS的加密解密的密钥，也就无法对https的数据解密了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>因为https有TLS加持，我们在TLS建立过程无法劫持到TLS的密钥，所以即便https数据被劫持也无法进行解密。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;https协议为什么能够防止劫持&quot;&gt;&lt;a href=&quot;#https协议为什么能够防止劫持&quot; class=&quot;headerlink&quot; title=&quot;https协议为什么能够防止劫持&quot;&gt;&lt;/a&gt;https协议为什么能够防止劫持&lt;/h2&gt;&lt;p&gt;在讲https为什么能够防止</summary>
      
    
    
    
    <category term="编程" scheme="http://blog.starant.link/categories/programming/"/>
    
    
    <category term="https" scheme="http://blog.starant.link/tags/https/"/>
    
    <category term="网络安全" scheme="http://blog.starant.link/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>linux快捷键大全</title>
    <link href="http://blog.starant.link/posts/26317.html"/>
    <id>http://blog.starant.link/posts/26317.html</id>
    <published>2023-07-19T07:58:51.000Z</published>
    <updated>2023-08-01T05:56:53.463Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Linux快捷键大全"><a href="#Linux快捷键大全" class="headerlink" title="Linux快捷键大全"></a>Linux快捷键大全</h2><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">1、tab //命令或路径等的补全键，linux用的最多的一个快捷键</span><br><span class="line">2、ctrl+a //光标迅速回到行首</span><br><span class="line">3、ctrl+e //光标迅速回到行尾</span><br><span class="line">4、ctrl+f //光标向右移动一个字符</span><br><span class="line">5、ctrl+b //光标向左移动一个字符</span><br><span class="line">6、ctrl+insert //复制命令行内容（mac系统不能使用）</span><br><span class="line">7、shift+insert //粘贴命令行内容（mac系统不能使用）</span><br><span class="line">8、ctrl+k //剪切（删除）光标处到行尾的所有字符</span><br><span class="line">9、ctrl+u //剪切（删除）光标处到行首的所有字符</span><br><span class="line">10、ctrl+w //剪切（删除）光标前的一个字符</span><br><span class="line">11、ctrl+y //粘贴 ctrl+k、ctrl+u、ctrl+w删除的字符</span><br><span class="line">12、ctrl+c //中断终端正在执行的任务并开启一个新的一行</span><br><span class="line">13、ctrl+h //删除光标前的一个字符（相当于退格键）</span><br><span class="line">14、ctrl+d //退出当前shell命令行，如果是切换过来的用户，则执行这个命令回退到原用户</span><br><span class="line">15、ctrl+r //搜索命令行使用过的历史命令记录</span><br><span class="line">16、ctrl+g //从ctrl+r的搜索历史命令模式中退出</span><br><span class="line">17、ctrl+l //清楚屏幕所有的内容，并开启一个新的一行</span><br><span class="line">18、ctrl+s //锁定终端，使之任何人无法输入</span><br><span class="line">19、ctrl+q //解锁ctrl+s的锁定状态</span><br><span class="line">20、ctrl+z //暂停在终端运行的任务,使用&quot;fg&quot;命令可以使暂停恢复</span><br><span class="line">21、!! //执行上一条命令</span><br><span class="line">22、!pw //这是一个例子，是执行以pw开头的命令，这里的pw可以换成任何已经执行过的字符</span><br><span class="line">23、!pw:p //这是一个例子，是仅打印以pw开头的命令，但不执行，最后的那个“p”是命令固定字符</span><br><span class="line">24、!num //执行历史命令列表的第num条命令，num代指任何数字（前提是历史命令里必须存在）</span><br><span class="line">25、!$ //代指上一条命令的最后一个参数，该命令常用于shell脚本中</span><br><span class="line">26、esc+. //注意那个&quot;.&quot; 意思是获取上一条命令的(以空格为分隔符)最后的部分</span><br><span class="line">27、esc+b //移动到当前单词的开头</span><br><span class="line">28、esc+f //移动到当前单词的结尾</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Linux快捷键大全&quot;&gt;&lt;a href=&quot;#Linux快捷键大全&quot; class=&quot;headerlink&quot; title=&quot;Linux快捷键大全&quot;&gt;&lt;/a&gt;Linux快捷键大全&lt;/h2&gt;&lt;h3 id=&quot;代码&quot;&gt;&lt;a href=&quot;#代码&quot; class=&quot;headerli</summary>
      
    
    
    
    
  </entry>
  
</feed>
